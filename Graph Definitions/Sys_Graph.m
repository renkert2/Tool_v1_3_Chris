classdef Sys_Graph < matlab.mixin.Copyable
    % Sys_Graph is a class for defining a system graph model. The
    % Sys_Graph class is generated by passing Comp_Graphs to the
    % GenSysGraph function
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Author: Christopher T. Aksland
    % Association: University of Illionis at Urbana-Champaign
    % Contact: aksland2@illinois.edu
    % Revision History:
    % 7/30/2020 - Class creation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Potential improvements 
    % - Change PType from character structure to sring array
    % - add in method that reorders states!
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    properties  % minimum properties needed to define graph
        
        % Number of Graph State Vertices
        Nv uint16 {mustBeNumeric, mustBeInteger}
        % Number of Graph Edges
        Ne uint16 {mustBeNumeric, mustBeInteger}
        % Number of Graph External Vertices
        Nev uint16 {mustBeNumeric, mustBeInteger}
        % Number of Graph External Edges
        Nee uint16 {mustBeNumeric, mustBeInteger}
        % Number of Graph Inputs
        Nu uint16 {mustBeNumeric, mustBeInteger}
        
        % Graph Edge Matrix:
        % FORMAT:
        % Column 1: Tail Vertex, Column 2: Head Vertex, Row: Edge
        E (:,2) uint16 {mustBeNumeric, mustBeInteger}
          
        % Graph Incidence Matrix
        M (:,:) {mustBeInteger, mustBeNumeric}
        
        % Modified Graph Incidence Matrix
        M_mod (:,:) {mustBeInteger, mustBeNumeric}
        
        % Tails Matrix
        Tails (:,:) {mustBeInteger, mustBeNumeric}
        
        % Heads Matrix
        Heads (:,:) {mustBeInteger, mustBeNumeric}
        
        % Input to Edge Mapping Matrices
        B (:,:)
        
        % External Edge to Vertex Matrix
        D (:,:) {mustBeInteger, mustBeNumeric}
        
        % Lookup Function to Vertex Mapping Matrices
        Fv (:,:)
        
        % Power Coefficient Matrix
        DynType (:,1) double {mustBeInteger}
         
        % Initial Condition Vector
        x_init (:,1) double {mustBeNumeric}
        
        % Capacitance Vector
        C_coeff (:,1) double {mustBeNumeric}
                
        % Power Coefficient Matrix
        P_coeff (:,:) double {mustBeNumeric}
        
        % Modified Power Coefficient Matrix
        P_coeff_mod (:,:) double {mustBeNumeric}
        
        % Fucntion Coefficient Matrix
        Fv_coeff (:,:) double {mustBeNumeric}
        
        % Graph Capacitance Type Definitions
        % Add Comments
        CType
        
        % Graph Power Flow Type Definitions
        % Defines the type of constant conefficient power flow types in the
        % graph definition. The power flow equation should be provided in
        % terms of: Tail State 'xt', Head State 'xh',
        % Inputs 'u1',...,'uN' and compatible Symbolic toolbox functions.
        % FORMAT:
        % PType(Type#).Type = 'String representing powerflow type'
        PType
        
        PType_mod
        
        % Graph Lookup Function Definitions
        % Add Comments
        FvType
        
        % Graph Rule Capacitance calculation
        Capacitance (:,1) CapacitanceType
        
        % Graph Rule Powerflow calculation
        PowerFlow (:,1) PowerFlowType
        
        % Generic Capacitance calculation
        VertexLookupFunction (:,1) LookupFunctionType
        
%         % Generic Powerflow calculation
%         EdgeLookupFunction (:,1) LookupFunctionType
%         
%         % Vertex Maps
%         vMaps (:,1) Graph_Map
%       
%         % Maps To Vertex Matrix
%         Map2v (:,:) 
% 
%         % Linear Graph
%         ContLinGraph (1,1) Linear_Graph
        
        % Symbolic Representation of graph model
        Symb
        
        % function to sovle for plant algebraic solutions
        solveAlg
       
        % function to solve for plant dynamic solutions
        solveDyn
    end
    
    methods
       
        % whenever the Edge matrix is updated, update the incidence matrix
        function set.M(obj,v)
            obj.M = v;
            obj.updateE
        end
        % this function builds the Edge matrix
        function updateE(obj)
            Nv_tot = size(obj.M,1);
            obj.Ne = size(obj.M,2); % total number of edges
            obj.E = zeros(obj.Ne,2); % edge matrix size initialization
            obj.E(:,1) = (1:Nv_tot)*(obj.M == 1); % set edge matrix tails
            obj.E(:,2) = (1:Nv_tot)*(obj.M == -1); % set edge matrix heads
            
            obj.Tails = double(obj.M'== 1);
            obj.Heads = double(obj.M'== -1);
            
            try
                obj.Nev = Nv_tot - obj.Nv;
            end
        end
        
        % whenever the vertex count updated, update the number of external
        % vertices
        function set.Nv(obj,v)
            obj.Nv = v;
            obj.updateNv
        end
        % this function calculates the number of external vertices
        function updateNv(obj)      
            try
                Nv_tot = size(obj.M,1);
                obj.Nev = Nv_tot - obj.Nv;
            end
        end

        function set.B(obj,v)
            obj.B = v;
            obj.updateNu;
        end
        function updateNu(obj)
            obj.Nu = size(obj.B.B1,2);
        end
        
        function set.D(obj,v)
            obj.D = v;
            obj.updateNee;
        end
        function updateNee(obj)
            obj.Nee = size(obj.D,2);
        end
            
        
        function ReorderX(obj,NewOrder)
           
            obj.M       = obj.M(NewOrder,:);
            obj.C_coeff = obj.C_coeff(NewOrder,:);
            obj.x_init  = obj.x_init(NewOrder,:);
            obj.D       = obj.D(NewOrder,:);
            obj.DynType = obj.DynType(NewOrder,:);
            
        end
        
        
        function plot(obj)
            figure
            G = digraph(obj.E(:,1),obj.E(:,2));
            h = plot(G);
            labeledge(h,obj.E(:,1)',obj.E(:,2)',1:size(obj.E,1));       
        end
        
    end
    
   

end
